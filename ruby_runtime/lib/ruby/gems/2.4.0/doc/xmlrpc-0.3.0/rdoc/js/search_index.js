var search_data = {"index":{"searchIndex":["xmlrpc","base64","basicserver","cgiserver","client","proxy","config","convert","create","datetime","faultexception","marshal","marshallable","modrubyserver","parsecontenttype","parserwriterchoosemixin","server","service","basicinterface","interface","publicinstancemethodsinterface","webrickservlet","xmlparser","abstractstreamparser","abstracttreeparser","libxmlstreamparser","libxmlstreamlistener","rexmlstreamparser","streamlistener","streamparsermixin","xmlwriter","abstract","simple","xmlparser","==()","add_handler()","add_introspection()","add_method()","add_multicall()","array()","assert()","base64()","base64()","boolean()","boolean()","call()","call2()","call2_async()","call_async()","call_method()","character()","check_arity()","conv2value()","create()","data()","datetime()","datetime()","day=()","decode()","decoded()","dispatch()","do_rpc()","document()","document()","document_to_str()","document_to_str()","double()","double()","dump()","dump_call()","dump_call()","dump_response()","dump_response()","dup_net_http()","each_installed_parser()","each_installed_writer()","ele()","element()","element()","encode()","encoded()","endelement()","fault()","fault()","gen_multicall()","get_default_handler()","get_instance()","get_methods()","get_methods()","get_service_hook()","get_valid_ip()","handle()","hasonlyonechild()","hour=()","http_error()","http_error()","http_write()","http_write()","int()","integer()","load()","load_call()","load_call()","load_response()","load_response()","member()","meth()","methodcall()","methodcall()","methodname()","methodresponse()","methodresponse()","method_missing()","method_missing()","method_missing()","min=()","mon=()","month=()","multicall()","multicall2()","multicall2_async()","multicall_async()","multicall_fault()","name()","net_http()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new2()","new3()","new_from_hash()","new_from_uri()","nodemustbe()","on_end_element_ns()","on_start_element_ns()","param()","params()","parse()","parse()","parsemethodcall()","parsemethodcall()","parsemethodresponse()","parsemethodresponse()","parse_content_type()","parse_set_cookies()","parse_sig()","parser()","password=()","pi()","pi()","process()","proxy()","proxy2()","proxy2_async()","proxy_async()","removewhitespacesandcomments()","require_path_info?()","sec=()","serve()","serve()","serve()","service()","set_auth()","set_default_handler()","set_parser()","set_service_hook()","set_valid_ip()","set_writer()","shutdown()","startelement()","string()","struct()","struct()","tag()","text()","text()","text()","text_zero_one()","timeout=()","to_a()","to_date()","to_h()","to_time()","user=()","v_nil()","value()","wrong_type()","year=()"],"longSearchIndex":["xmlrpc","xmlrpc::base64","xmlrpc::basicserver","xmlrpc::cgiserver","xmlrpc::client","xmlrpc::client::proxy","xmlrpc::config","xmlrpc::convert","xmlrpc::create","xmlrpc::datetime","xmlrpc::faultexception","xmlrpc::marshal","xmlrpc::marshallable","xmlrpc::modrubyserver","xmlrpc::parsecontenttype","xmlrpc::parserwriterchoosemixin","xmlrpc::server","xmlrpc::service","xmlrpc::service::basicinterface","xmlrpc::service::interface","xmlrpc::service::publicinstancemethodsinterface","xmlrpc::webrickservlet","xmlrpc::xmlparser","xmlrpc::xmlparser::abstractstreamparser","xmlrpc::xmlparser::abstracttreeparser","xmlrpc::xmlparser::libxmlstreamparser","xmlrpc::xmlparser::libxmlstreamparser::libxmlstreamlistener","xmlrpc::xmlparser::rexmlstreamparser","xmlrpc::xmlparser::rexmlstreamparser::streamlistener","xmlrpc::xmlparser::streamparsermixin","xmlrpc::xmlwriter","xmlrpc::xmlwriter::abstract","xmlrpc::xmlwriter::simple","xmlrpc::xmlwriter::xmlparser","xmlrpc::datetime#==()","xmlrpc::basicserver#add_handler()","xmlrpc::basicserver#add_introspection()","xmlrpc::service::basicinterface#add_method()","xmlrpc::basicserver#add_multicall()","xmlrpc::xmlparser::abstracttreeparser#array()","xmlrpc::xmlparser::abstracttreeparser#assert()","xmlrpc::convert::base64()","xmlrpc::xmlparser::abstracttreeparser#base64()","xmlrpc::convert::boolean()","xmlrpc::xmlparser::abstracttreeparser#boolean()","xmlrpc::client#call()","xmlrpc::client#call2()","xmlrpc::client#call2_async()","xmlrpc::client#call_async()","xmlrpc::basicserver#call_method()","xmlrpc::xmlparser::streamparsermixin#character()","xmlrpc::basicserver#check_arity()","xmlrpc::create#conv2value()","xmlrpc::parserwriterchoosemixin#create()","xmlrpc::xmlparser::abstracttreeparser#data()","xmlrpc::convert::datetime()","xmlrpc::xmlparser::abstracttreeparser#datetime()","xmlrpc::datetime#day=()","xmlrpc::base64::decode()","xmlrpc::base64#decoded()","xmlrpc::basicserver#dispatch()","xmlrpc::client#do_rpc()","xmlrpc::xmlwriter::simple#document()","xmlrpc::xmlwriter::xmlparser#document()","xmlrpc::xmlwriter::simple#document_to_str()","xmlrpc::xmlwriter::xmlparser#document_to_str()","xmlrpc::convert::double()","xmlrpc::xmlparser::abstracttreeparser#double()","xmlrpc::marshal::dump()","xmlrpc::marshal::dump_call()","xmlrpc::marshal#dump_call()","xmlrpc::marshal::dump_response()","xmlrpc::marshal#dump_response()","xmlrpc::client#dup_net_http()","xmlrpc::xmlparser::each_installed_parser()","xmlrpc::xmlwriter::each_installed_writer()","xmlrpc::xmlwriter::abstract#ele()","xmlrpc::xmlwriter::simple#element()","xmlrpc::xmlwriter::xmlparser#element()","xmlrpc::base64::encode()","xmlrpc::base64#encoded()","xmlrpc::xmlparser::streamparsermixin#endelement()","xmlrpc::convert::fault()","xmlrpc::xmlparser::abstracttreeparser#fault()","xmlrpc::client#gen_multicall()","xmlrpc::basicserver#get_default_handler()","xmlrpc::webrickservlet#get_instance()","xmlrpc::service::interface#get_methods()","xmlrpc::service::publicinstancemethodsinterface#get_methods()","xmlrpc::basicserver#get_service_hook()","xmlrpc::webrickservlet#get_valid_ip()","xmlrpc::basicserver#handle()","xmlrpc::xmlparser::abstracttreeparser#hasonlyonechild()","xmlrpc::datetime#hour=()","xmlrpc::cgiserver#http_error()","xmlrpc::modrubyserver#http_error()","xmlrpc::cgiserver#http_write()","xmlrpc::modrubyserver#http_write()","xmlrpc::convert::int()","xmlrpc::xmlparser::abstracttreeparser#integer()","xmlrpc::marshal::load()","xmlrpc::marshal#load_call()","xmlrpc::marshal::load_call()","xmlrpc::marshal#load_response()","xmlrpc::marshal::load_response()","xmlrpc::xmlparser::abstracttreeparser#member()","xmlrpc::service::interface#meth()","xmlrpc::create#methodcall()","xmlrpc::xmlparser::abstracttreeparser#methodcall()","xmlrpc::xmlparser::abstracttreeparser#methodname()","xmlrpc::create#methodresponse()","xmlrpc::xmlparser::abstracttreeparser#methodresponse()","xmlrpc::client::proxy#method_missing()","xmlrpc::xmlparser::libxmlstreamparser::libxmlstreamlistener#method_missing()","xmlrpc::xmlparser::rexmlstreamparser::streamlistener#method_missing()","xmlrpc::datetime#min=()","xmlrpc::datetime#mon=()","xmlrpc::datetime#month=()","xmlrpc::client#multicall()","xmlrpc::client#multicall2()","xmlrpc::client#multicall2_async()","xmlrpc::client#multicall_async()","xmlrpc::basicserver#multicall_fault()","xmlrpc::xmlparser::abstracttreeparser#name()","xmlrpc::client#net_http()","xmlrpc::base64::new()","xmlrpc::basicserver::new()","xmlrpc::cgiserver::new()","xmlrpc::cgiserver::new()","xmlrpc::client::new()","xmlrpc::client::proxy::new()","xmlrpc::create::new()","xmlrpc::datetime::new()","xmlrpc::faultexception::new()","xmlrpc::marshal::new()","xmlrpc::modrubyserver::new()","xmlrpc::server::new()","xmlrpc::service::basicinterface::new()","xmlrpc::service::interface::new()","xmlrpc::service::publicinstancemethodsinterface::new()","xmlrpc::webrickservlet::new()","xmlrpc::xmlparser::libxmlstreamparser::new()","xmlrpc::xmlparser::rexmlstreamparser::new()","xmlrpc::xmlparser::streamparsermixin::new()","xmlrpc::xmlwriter::xmlparser::new()","xmlrpc::client::new2()","xmlrpc::client::new3()","xmlrpc::client::new_from_hash()","xmlrpc::client::new_from_uri()","xmlrpc::xmlparser::abstracttreeparser#nodemustbe()","xmlrpc::xmlparser::libxmlstreamparser::libxmlstreamlistener#on_end_element_ns()","xmlrpc::xmlparser::libxmlstreamparser::libxmlstreamlistener#on_start_element_ns()","xmlrpc::xmlparser::abstracttreeparser#param()","xmlrpc::xmlparser::abstracttreeparser#params()","xmlrpc::xmlparser::libxmlstreamparser::libxmlstreamlistener#parse()","xmlrpc::xmlparser::rexmlstreamparser::streamlistener#parse()","xmlrpc::xmlparser::abstractstreamparser#parsemethodcall()","xmlrpc::xmlparser::abstracttreeparser#parsemethodcall()","xmlrpc::xmlparser::abstractstreamparser#parsemethodresponse()","xmlrpc::xmlparser::abstracttreeparser#parsemethodresponse()","xmlrpc::parsecontenttype#parse_content_type()","xmlrpc::client#parse_set_cookies()","xmlrpc::service::basicinterface#parse_sig()","xmlrpc::parserwriterchoosemixin#parser()","xmlrpc::client#password=()","xmlrpc::xmlwriter::simple#pi()","xmlrpc::xmlwriter::xmlparser#pi()","xmlrpc::basicserver#process()","xmlrpc::client#proxy()","xmlrpc::client#proxy2()","xmlrpc::client#proxy2_async()","xmlrpc::client#proxy_async()","xmlrpc::xmlparser::abstracttreeparser#removewhitespacesandcomments()","xmlrpc::webrickservlet#require_path_info?()","xmlrpc::datetime#sec=()","xmlrpc::cgiserver#serve()","xmlrpc::modrubyserver#serve()","xmlrpc::server#serve()","xmlrpc::webrickservlet#service()","xmlrpc::client#set_auth()","xmlrpc::basicserver#set_default_handler()","xmlrpc::parserwriterchoosemixin#set_parser()","xmlrpc::basicserver#set_service_hook()","xmlrpc::webrickservlet#set_valid_ip()","xmlrpc::parserwriterchoosemixin#set_writer()","xmlrpc::server#shutdown()","xmlrpc::xmlparser::streamparsermixin#startelement()","xmlrpc::xmlparser::abstracttreeparser#string()","xmlrpc::convert::struct()","xmlrpc::xmlparser::abstracttreeparser#struct()","xmlrpc::xmlwriter::abstract#tag()","xmlrpc::xmlparser::abstracttreeparser#text()","xmlrpc::xmlwriter::simple#text()","xmlrpc::xmlwriter::xmlparser#text()","xmlrpc::xmlparser::abstracttreeparser#text_zero_one()","xmlrpc::client#timeout=()","xmlrpc::datetime#to_a()","xmlrpc::datetime#to_date()","xmlrpc::faultexception#to_h()","xmlrpc::datetime#to_time()","xmlrpc::client#user=()","xmlrpc::xmlparser::abstracttreeparser#v_nil()","xmlrpc::xmlparser::abstracttreeparser#value()","xmlrpc::create#wrong_type()","xmlrpc::datetime#year=()"],"info":[["XMLRPC","","XMLRPC.html","","<p>Author and Copyright\n<p>Copyright (C) 2001-2004 by Michael Neumann (mneumann@ntecs.de)\n<p>Released under the …\n"],["XMLRPC::Base64","","XMLRPC/Base64.html","","<p>This class is necessary for &#39;xmlrpc4r&#39; to determine that a string\nshould be transmitted base64-encoded …\n"],["XMLRPC::BasicServer","","XMLRPC/BasicServer.html","","<p>This is the base class for all XML-RPC server-types (CGI, standalone). You\ncan add handler and set a …\n"],["XMLRPC::CGIServer","","XMLRPC/CGIServer.html","","<p>Implements a CGI-based XML-RPC server.\n\n<pre>require &quot;xmlrpc/server&quot;\n\ns = XMLRPC::CGIServer.new\n\ns.add_handler(&quot;michael.add&quot;) ...</pre>\n"],["XMLRPC::Client","","XMLRPC/Client.html","","<p>Provides remote procedure calls to a XML-RPC server.\n<p>After setting the connection-parameters with XMLRPC::Client.new …\n"],["XMLRPC::Client::Proxy","","XMLRPC/Client/Proxy.html","","<p>XML-RPC calls look nicer!\n<p>You can call any method onto objects of that class - the object handles\nXMLRPC::Client::Proxy#method_missing …\n"],["XMLRPC::Config","","XMLRPC/Config.html","",""],["XMLRPC::Convert","","XMLRPC/Convert.html","","<p>Helper class used to convert types.\n"],["XMLRPC::Create","","XMLRPC/Create.html","","<p>Creates XML-RPC call/response documents\n"],["XMLRPC::DateTime","","XMLRPC/DateTime.html","","<p>This class is important to handle XMLRPC <code>dateTime.iso8601</code>\nvalues, correctly, because normal UNIX-dates, …\n"],["XMLRPC::FaultException","","XMLRPC/FaultException.html","","<p>Raised when the remote procedure returns a fault-structure, which has two\naccessor-methods <code>faultCode</code> …\n"],["XMLRPC::Marshal","","XMLRPC/Marshal.html","","<p>Marshalling of XMLRPC::Create#methodCall and XMLRPC::Create#methodResponse\n"],["XMLRPC::Marshallable","","XMLRPC/Marshallable.html","","<p>This module enables a user-class to be marshalled by XML-RPC for Ruby into\na Hash, with one additional …\n"],["XMLRPC::ModRubyServer","","XMLRPC/ModRubyServer.html","","<p>Implements a XML-RPC server, which works with Apache mod_ruby.\n<p>Use it in the same way as XMLRPC::CGIServer …\n"],["XMLRPC::ParseContentType","","XMLRPC/ParseContentType.html","",""],["XMLRPC::ParserWriterChooseMixin","","XMLRPC/ParserWriterChooseMixin.html","","<p>Defines ParserWriterChooseMixin, which makes it possible to choose a\ndifferent XMLWriter and/or XMLParser …\n"],["XMLRPC::Server","","XMLRPC/Server.html","","<p>Implements a standalone XML-RPC server. The method XMLRPC::Server#serve is\nleft if a SIGHUP is sent to …\n"],["XMLRPC::Service","","XMLRPC/Service.html","",""],["XMLRPC::Service::BasicInterface","","XMLRPC/Service/BasicInterface.html","","<p>Base class for XMLRPC::Service::Interface definitions, used by\nXMLRPC::BasicServer#add_handler\n"],["XMLRPC::Service::Interface","","XMLRPC/Service/Interface.html","","<p>Class which wraps a XMLRPC::Service::Interface definition, used by\nXMLRPC::BasicServer#add_handler\n"],["XMLRPC::Service::PublicInstanceMethodsInterface","","XMLRPC/Service/PublicInstanceMethodsInterface.html","",""],["XMLRPC::WEBrickServlet","","XMLRPC/WEBrickServlet.html","","<p>Implements a servlet for use with WEBrick, a pure Ruby (HTTP) server\nframework.\n\n<pre>require &quot;webrick&quot;\nrequire ...</pre>\n"],["XMLRPC::XMLParser","","XMLRPC/XMLParser.html","","<p>Parser for XML-RPC call and response\n"],["XMLRPC::XMLParser::AbstractStreamParser","","XMLRPC/XMLParser/AbstractStreamParser.html","",""],["XMLRPC::XMLParser::AbstractTreeParser","","XMLRPC/XMLParser/AbstractTreeParser.html","",""],["XMLRPC::XMLParser::LibXMLStreamParser","","XMLRPC/XMLParser/LibXMLStreamParser.html","",""],["XMLRPC::XMLParser::LibXMLStreamParser::LibXMLStreamListener","","XMLRPC/XMLParser/LibXMLStreamParser/LibXMLStreamListener.html","",""],["XMLRPC::XMLParser::REXMLStreamParser","","XMLRPC/XMLParser/REXMLStreamParser.html","",""],["XMLRPC::XMLParser::REXMLStreamParser::StreamListener","","XMLRPC/XMLParser/REXMLStreamParser/StreamListener.html","",""],["XMLRPC::XMLParser::StreamParserMixin","","XMLRPC/XMLParser/StreamParserMixin.html","",""],["XMLRPC::XMLWriter","","XMLRPC/XMLWriter.html","",""],["XMLRPC::XMLWriter::Abstract","","XMLRPC/XMLWriter/Abstract.html","",""],["XMLRPC::XMLWriter::Simple","","XMLRPC/XMLWriter/Simple.html","",""],["XMLRPC::XMLWriter::XMLParser","","XMLRPC/XMLWriter/XMLParser.html","",""],["==","XMLRPC::DateTime","XMLRPC/DateTime.html#method-i-3D-3D","(o)","<p>Returns whether or not all date/time components are an array.\n"],["add_handler","XMLRPC::BasicServer","XMLRPC/BasicServer.html#method-i-add_handler","(prefix, obj_or_signature=nil, help=nil, &block)","<p>Adds <code>aBlock</code> to the list of handlers, with <code>name</code> as\nthe name of the method.\n<p>Parameters <code>signature</code> and <code>help</code> …\n"],["add_introspection","XMLRPC::BasicServer","XMLRPC/BasicServer.html#method-i-add_introspection","()","<p>Adds the introspection handlers\n<code>&quot;system.listMethods&quot;</code>,\n<code>&quot;system.methodSignature&quot;</code> and …\n"],["add_method","XMLRPC::Service::BasicInterface","XMLRPC/Service/BasicInterface.html#method-i-add_method","(sig, help=nil, meth_name=nil)",""],["add_multicall","XMLRPC::BasicServer","XMLRPC/BasicServer.html#method-i-add_multicall","()","<p>Adds the multi-call handler <code>&quot;system.multicall&quot;</code>.\n"],["array","XMLRPC::XMLParser::AbstractTreeParser","XMLRPC/XMLParser/AbstractTreeParser.html#method-i-array","(node)",""],["assert","XMLRPC::XMLParser::AbstractTreeParser","XMLRPC/XMLParser/AbstractTreeParser.html#method-i-assert","(b)",""],["base64","XMLRPC::Convert","XMLRPC/Convert.html#method-c-base64","(str)","<p>Decodes the given <code>str</code> using XMLRPC::Base64.decode\n"],["base64","XMLRPC::XMLParser::AbstractTreeParser","XMLRPC/XMLParser/AbstractTreeParser.html#method-i-base64","(node)",""],["boolean","XMLRPC::Convert","XMLRPC/Convert.html#method-c-boolean","(str)","<p>Converts a String to <code>true</code> or <code>false</code>\n<p>Raises an exception if <code>str</code> is not <code>0</code> or\n<code>1</code>\n"],["boolean","XMLRPC::XMLParser::AbstractTreeParser","XMLRPC/XMLParser/AbstractTreeParser.html#method-i-boolean","(node)",""],["call","XMLRPC::Client","XMLRPC/Client.html#method-i-call","(method, *args)","<p>Invokes the method named <code>method</code> with the parameters given by\n<code>args</code> on the XML-RPC server.\n<p>The <code>method</code> parameter …\n"],["call2","XMLRPC::Client","XMLRPC/Client.html#method-i-call2","(method, *args)","<p>The difference between this method and XMLRPC::Client#call is, that this\nmethod will <strong>NOT</strong> raise a XMLRPC::FaultException …\n"],["call2_async","XMLRPC::Client","XMLRPC/Client.html#method-i-call2_async","(method, *args)","<p>Same as XMLRPC::Client#call2, but can be called concurrently.\n<p>See also XMLRPC::Client#call_async\n"],["call_async","XMLRPC::Client","XMLRPC/Client.html#method-i-call_async","(method, *args)","<p>Similar to XMLRPC::Client#call, however can be called concurrently and use\na new connection for each …\n"],["call_method","XMLRPC::BasicServer","XMLRPC/BasicServer.html#method-i-call_method","(methodname, *args)",""],["character","XMLRPC::XMLParser::StreamParserMixin","XMLRPC/XMLParser/StreamParserMixin.html#method-i-character","(data)",""],["check_arity","XMLRPC::BasicServer","XMLRPC/BasicServer.html#method-i-check_arity","(obj, n_args)","<p>Returns <code>true</code>, if the arity of <code>obj</code> matches\n<code>n_args</code>\n"],["conv2value","XMLRPC::Create","XMLRPC/Create.html#method-i-conv2value","(param)","<p>Converts a Ruby object into a XML-RPC <code>&lt;value&gt;</code> tag\n"],["create","XMLRPC::ParserWriterChooseMixin","XMLRPC/ParserWriterChooseMixin.html#method-i-create","()",""],["data","XMLRPC::XMLParser::AbstractTreeParser","XMLRPC/XMLParser/AbstractTreeParser.html#method-i-data","(node)",""],["dateTime","XMLRPC::Convert","XMLRPC/Convert.html#method-c-dateTime","(str)","<p>Converts a the given <code>str</code> to a <code>dateTime.iso8601</code>\nformatted date.\n<p>Raises an exception if the String isn&#39;t …\n"],["dateTime","XMLRPC::XMLParser::AbstractTreeParser","XMLRPC/XMLParser/AbstractTreeParser.html#method-i-dateTime","(node)",""],["day=","XMLRPC::DateTime","XMLRPC/DateTime.html#method-i-day-3D","(value)","<p>Set <code>value</code> as the new date/time component.\n<p>Raises an ArgumentError if the given <code>value</code> isn&#39;t between …\n"],["decode","XMLRPC::Base64","XMLRPC/Base64.html#method-c-decode","(str)","<p>Decodes string <code>str</code> with base64 and returns that value.\n"],["decoded","XMLRPC::Base64","XMLRPC/Base64.html#method-i-decoded","()","<p>Returns the decoded internal string.\n"],["dispatch","XMLRPC::BasicServer","XMLRPC/BasicServer.html#method-i-dispatch","(methodname, *args)",""],["do_rpc","XMLRPC::Client","XMLRPC/Client.html#method-i-do_rpc","(request, async=false)",""],["document","XMLRPC::XMLWriter::Simple","XMLRPC/XMLWriter/Simple.html#method-i-document","(*params)",""],["document","XMLRPC::XMLWriter::XMLParser","XMLRPC/XMLWriter/XMLParser.html#method-i-document","(*params)",""],["document_to_str","XMLRPC::XMLWriter::Simple","XMLRPC/XMLWriter/Simple.html#method-i-document_to_str","(doc)",""],["document_to_str","XMLRPC::XMLWriter::XMLParser","XMLRPC/XMLWriter/XMLParser.html#method-i-document_to_str","(doc)",""],["double","XMLRPC::Convert","XMLRPC/Convert.html#method-c-double","(str)","<p>Converts a String to a Float\n<p>See also String.to_f\n"],["double","XMLRPC::XMLParser::AbstractTreeParser","XMLRPC/XMLParser/AbstractTreeParser.html#method-i-double","(node)",""],["dump","XMLRPC::Marshal","XMLRPC/Marshal.html#method-c-dump","( param )",""],["dump_call","XMLRPC::Marshal","XMLRPC/Marshal.html#method-c-dump_call","( methodName, *params )",""],["dump_call","XMLRPC::Marshal","XMLRPC/Marshal.html#method-i-dump_call","( methodName, *params )",""],["dump_response","XMLRPC::Marshal","XMLRPC/Marshal.html#method-c-dump_response","( param )",""],["dump_response","XMLRPC::Marshal","XMLRPC/Marshal.html#method-i-dump_response","( param )",""],["dup_net_http","XMLRPC::Client","XMLRPC/Client.html#method-i-dup_net_http","()",""],["each_installed_parser","XMLRPC::XMLParser","XMLRPC/XMLParser.html#method-c-each_installed_parser","()","<p>yields an instance of each installed parser\n"],["each_installed_writer","XMLRPC::XMLWriter","XMLRPC/XMLWriter.html#method-c-each_installed_writer","()","<p>yields an instance of each installed XML writer\n"],["ele","XMLRPC::XMLWriter::Abstract","XMLRPC/XMLWriter/Abstract.html#method-i-ele","(name, *children)",""],["element","XMLRPC::XMLWriter::Simple","XMLRPC/XMLWriter/Simple.html#method-i-element","(name, attrs, *children)",""],["element","XMLRPC::XMLWriter::XMLParser","XMLRPC/XMLWriter/XMLParser.html#method-i-element","(name, attrs, *children)",""],["encode","XMLRPC::Base64","XMLRPC/Base64.html#method-c-encode","(str)","<p>Encodes string <code>str</code> with base64 and returns that value.\n"],["encoded","XMLRPC::Base64","XMLRPC/Base64.html#method-i-encoded","()","<p>Returns the base64 encoded internal string.\n"],["endElement","XMLRPC::XMLParser::StreamParserMixin","XMLRPC/XMLParser/StreamParserMixin.html#method-i-endElement","(name)",""],["fault","XMLRPC::Convert","XMLRPC/Convert.html#method-c-fault","(hash)","<p>Converts the given <code>hash</code> to an XMLRPC::FaultException object by\npassing the <code>faultCode</code> and <code>faultString</code> …\n"],["fault","XMLRPC::XMLParser::AbstractTreeParser","XMLRPC/XMLParser/AbstractTreeParser.html#method-i-fault","(node)",""],["gen_multicall","XMLRPC::Client","XMLRPC/Client.html#method-i-gen_multicall","(methods=[], async=false)",""],["get_default_handler","XMLRPC::BasicServer","XMLRPC/BasicServer.html#method-i-get_default_handler","()","<p>Returns the default-handler, which is called when no handler for a\nmethod-name is found.\n<p>It is either …\n"],["get_instance","XMLRPC::WEBrickServlet","XMLRPC/WEBrickServlet.html#method-i-get_instance","(config, *options)",""],["get_methods","XMLRPC::Service::Interface","XMLRPC/Service/Interface.html#method-i-get_methods","(obj, delim=\".\")",""],["get_methods","XMLRPC::Service::PublicInstanceMethodsInterface","XMLRPC/Service/PublicInstanceMethodsInterface.html#method-i-get_methods","(obj, delim=\".\")",""],["get_service_hook","XMLRPC::BasicServer","XMLRPC/BasicServer.html#method-i-get_service_hook","()","<p>Returns the service-hook, which is called on each service request (RPC)\nunless it&#39;s <code>nil</code>.\n"],["get_valid_ip","XMLRPC::WEBrickServlet","XMLRPC/WEBrickServlet.html#method-i-get_valid_ip","()","<p>Return the valid IP addresses that are allowed to connect to the server.\n<p>See also, XMLRPC::Server#set_valid_ip …\n"],["handle","XMLRPC::BasicServer","XMLRPC/BasicServer.html#method-i-handle","(methodname, *args)",""],["hasOnlyOneChild","XMLRPC::XMLParser::AbstractTreeParser","XMLRPC/XMLParser/AbstractTreeParser.html#method-i-hasOnlyOneChild","(node, name=nil)","<p>Returns, when successfully the only child-node\n"],["hour=","XMLRPC::DateTime","XMLRPC/DateTime.html#method-i-hour-3D","(value)","<p>Set <code>value</code> as the new date/time component.\n<p>Raises an ArgumentError if the given <code>value</code> isn&#39;t between …\n"],["http_error","XMLRPC::CGIServer","XMLRPC/CGIServer.html#method-i-http_error","(status, message)",""],["http_error","XMLRPC::ModRubyServer","XMLRPC/ModRubyServer.html#method-i-http_error","(status, message)",""],["http_write","XMLRPC::CGIServer","XMLRPC/CGIServer.html#method-i-http_write","(body, header)",""],["http_write","XMLRPC::ModRubyServer","XMLRPC/ModRubyServer.html#method-i-http_write","(body, status, header)",""],["int","XMLRPC::Convert","XMLRPC/Convert.html#method-c-int","(str)","<p>Converts a String to an Integer\n<p>See also String.to_i\n"],["integer","XMLRPC::XMLParser::AbstractTreeParser","XMLRPC/XMLParser/AbstractTreeParser.html#method-i-integer","(node)",""],["load","XMLRPC::Marshal","XMLRPC/Marshal.html#method-c-load","( stringOrReadable )",""],["load_call","XMLRPC::Marshal","XMLRPC/Marshal.html#method-i-load_call","( stringOrReadable )","<p>Returns <code>[ methodname, params ]</code>\n"],["load_call","XMLRPC::Marshal","XMLRPC/Marshal.html#method-c-load_call","( stringOrReadable )",""],["load_response","XMLRPC::Marshal","XMLRPC/Marshal.html#method-i-load_response","( stringOrReadable )","<p>Returns <code>paramOrFault</code>\n"],["load_response","XMLRPC::Marshal","XMLRPC/Marshal.html#method-c-load_response","( stringOrReadable )",""],["member","XMLRPC::XMLParser::AbstractTreeParser","XMLRPC/XMLParser/AbstractTreeParser.html#method-i-member","(node)",""],["meth","XMLRPC::Service::Interface","XMLRPC/Service/Interface.html#method-i-meth","(*a)",""],["methodCall","XMLRPC::Create","XMLRPC/Create.html#method-i-methodCall","(name, *params)",""],["methodCall","XMLRPC::XMLParser::AbstractTreeParser","XMLRPC/XMLParser/AbstractTreeParser.html#method-i-methodCall","(node)",""],["methodName","XMLRPC::XMLParser::AbstractTreeParser","XMLRPC/XMLParser/AbstractTreeParser.html#method-i-methodName","(node)",""],["methodResponse","XMLRPC::Create","XMLRPC/Create.html#method-i-methodResponse","(is_ret, *params)","<p>Generates a XML-RPC methodResponse document\n<p>When <code>is_ret</code> is <code>false</code> then the <code>params</code>\narray must contain only …\n"],["methodResponse","XMLRPC::XMLParser::AbstractTreeParser","XMLRPC/XMLParser/AbstractTreeParser.html#method-i-methodResponse","(node)",""],["method_missing","XMLRPC::Client::Proxy","XMLRPC/Client/Proxy.html#method-i-method_missing","(mid, *args)","<p>Every method call is forwarded to the XML-RPC server defined in\nXMLRPC::Client::Proxy#new.\n<p>Note: Inherited …\n"],["method_missing","XMLRPC::XMLParser::LibXMLStreamParser::LibXMLStreamListener","XMLRPC/XMLParser/LibXMLStreamParser/LibXMLStreamListener.html#method-i-method_missing","(*a)",""],["method_missing","XMLRPC::XMLParser::REXMLStreamParser::StreamListener","XMLRPC/XMLParser/REXMLStreamParser/StreamListener.html#method-i-method_missing","(*a)",""],["min=","XMLRPC::DateTime","XMLRPC/DateTime.html#method-i-min-3D","(value)","<p>Set <code>value</code> as the new date/time component.\n<p>Raises an ArgumentError if the given <code>value</code> isn&#39;t between …\n"],["mon=","XMLRPC::DateTime","XMLRPC/DateTime.html#method-i-mon-3D","(value)","<p>Alias for XMLRPC::DateTime#month=.\n"],["month=","XMLRPC::DateTime","XMLRPC/DateTime.html#method-i-month-3D","(value)","<p>Set <code>value</code> as the new date/time component.\n<p>Raises an ArgumentError if the given <code>value</code> isn&#39;t between …\n"],["multicall","XMLRPC::Client","XMLRPC/Client.html#method-i-multicall","(*methods)","<p>You can use this method to execute several methods on a XMLRPC server which\nsupport the multi-call extension. …\n"],["multicall2","XMLRPC::Client","XMLRPC/Client.html#method-i-multicall2","(*methods)","<p>Same as XMLRPC::Client#multicall, but returns two parameters instead of\nraising an XMLRPC::FaultException …\n"],["multicall2_async","XMLRPC::Client","XMLRPC/Client.html#method-i-multicall2_async","(*methods)","<p>Same as XMLRPC::Client#multicall2, but can be called concurrently.\n<p>See also XMLRPC::Client#multicall_async …\n"],["multicall_async","XMLRPC::Client","XMLRPC/Client.html#method-i-multicall_async","(*methods)","<p>Similar to XMLRPC::Client#multicall, however can be called concurrently and\nuse a new connection for …\n"],["multicall_fault","XMLRPC::BasicServer","XMLRPC/BasicServer.html#method-i-multicall_fault","(nr, str)",""],["name","XMLRPC::XMLParser::AbstractTreeParser","XMLRPC/XMLParser/AbstractTreeParser.html#method-i-name","(node)",""],["net_http","XMLRPC::Client","XMLRPC/Client.html#method-i-net_http","(host, port, proxy_host, proxy_port)",""],["new","XMLRPC::Base64","XMLRPC/Base64.html#method-c-new","(str, state = :dec)","<p>Creates a new XMLRPC::Base64 instance with string <code>str</code> as the\ninternal string. When <code>state</code> is <code>:dec</code> it assumes …\n"],["new","XMLRPC::BasicServer","XMLRPC/BasicServer.html#method-c-new","(class_delim=\".\")","<p>Creates a new XMLRPC::BasicServer instance, which should not be done,\nbecause XMLRPC::BasicServer is …\n"],["new","XMLRPC::CGIServer","XMLRPC/CGIServer.html#method-c-new","(*a)","<p>Creates a new XMLRPC::CGIServer instance.\n<p>All parameters given are by-passed to XMLRPC::BasicServer.new …\n"],["new","XMLRPC::CGIServer","XMLRPC/CGIServer.html#method-c-new","(*a)",""],["new","XMLRPC::Client","XMLRPC/Client.html#method-c-new","(host=nil, path=nil, port=nil, proxy_host=nil, proxy_port=nil, user=nil, password=nil, use_ssl=nil, timeout=nil)","<p>Creates an object which represents the remote XML-RPC server on the given\n<code>host</code>. If the server is CGI-based, …\n"],["new","XMLRPC::Client::Proxy","XMLRPC/Client/Proxy.html#method-c-new","(server, prefix, args=[], meth=:call, delim=\".\")","<p>Creates an object which provides XMLRPC::Client::Proxy#method_missing.\n<p>The given <code>server</code> must be an instance …\n"],["new","XMLRPC::Create","XMLRPC/Create.html#method-c-new","(xml_writer = nil)",""],["new","XMLRPC::DateTime","XMLRPC/DateTime.html#method-c-new","(year, month, day, hour, min, sec)","<p>Creates a new XMLRPC::DateTime instance with the parameters\n<code>year</code>, <code>month</code>, <code>day</code> as date and\n<code>hour</code>, <code>min</code>,  …\n"],["new","XMLRPC::FaultException","XMLRPC/FaultException.html#method-c-new","(faultCode, faultString)","<p>Creates a new XMLRPC::FaultException instance.\n<p><code>faultString</code> is passed to StandardError as the <code>msg</code>\nof the …\n"],["new","XMLRPC::Marshal","XMLRPC/Marshal.html#method-c-new","( parser = nil, writer = nil )",""],["new","XMLRPC::ModRubyServer","XMLRPC/ModRubyServer.html#method-c-new","(*a)","<p>Creates a new XMLRPC::ModRubyServer instance.\n<p>All parameters given are by-passed to XMLRPC::BasicServer.new …\n"],["new","XMLRPC::Server","XMLRPC/Server.html#method-c-new","(port=8080, host=\"127.0.0.1\", maxConnections=4, stdlog=$stdout, audit=true, debug=true, *a)","<p>Creates a new XMLRPC::Server instance, which is a XML-RPC server listening\non the given <code>port</code> and accepts …\n"],["new","XMLRPC::Service::BasicInterface","XMLRPC/Service/BasicInterface.html#method-c-new","(prefix)",""],["new","XMLRPC::Service::Interface","XMLRPC/Service/Interface.html#method-c-new","(prefix, &p)",""],["new","XMLRPC::Service::PublicInstanceMethodsInterface","XMLRPC/Service/PublicInstanceMethodsInterface.html#method-c-new","(prefix)",""],["new","XMLRPC::WEBrickServlet","XMLRPC/WEBrickServlet.html#method-c-new","(*a)",""],["new","XMLRPC::XMLParser::LibXMLStreamParser","XMLRPC/XMLParser/LibXMLStreamParser.html#method-c-new","()",""],["new","XMLRPC::XMLParser::REXMLStreamParser","XMLRPC/XMLParser/REXMLStreamParser.html#method-c-new","()",""],["new","XMLRPC::XMLParser::StreamParserMixin","XMLRPC/XMLParser/StreamParserMixin.html#method-c-new","(*a)",""],["new","XMLRPC::XMLWriter::XMLParser","XMLRPC/XMLWriter/XMLParser.html#method-c-new","()",""],["new2","XMLRPC::Client","XMLRPC/Client.html#method-c-new2","(uri, proxy=nil, timeout=nil)","<p>Creates an object which represents the remote XML-RPC server at the given\n<code>uri</code>. The URI should have a …\n"],["new3","XMLRPC::Client","XMLRPC/Client.html#method-c-new3","(hash={})","<p>Receives a Hash and calls XMLRPC::Client.new with the corresponding values.\n<p>The <code>hash</code> parameter has following …\n"],["new_from_hash","XMLRPC::Client","XMLRPC/Client.html#method-c-new_from_hash","(hash={})",""],["new_from_uri","XMLRPC::Client","XMLRPC/Client.html#method-c-new_from_uri","(uri, proxy=nil, timeout=nil)",""],["nodeMustBe","XMLRPC::XMLParser::AbstractTreeParser","XMLRPC/XMLParser/AbstractTreeParser.html#method-i-nodeMustBe","(node, name)",""],["on_end_element_ns","XMLRPC::XMLParser::LibXMLStreamParser::LibXMLStreamListener","XMLRPC/XMLParser/LibXMLStreamParser/LibXMLStreamListener.html#method-i-on_end_element_ns","(name, prefix, uri)",""],["on_start_element_ns","XMLRPC::XMLParser::LibXMLStreamParser::LibXMLStreamListener","XMLRPC/XMLParser/LibXMLStreamParser/LibXMLStreamListener.html#method-i-on_start_element_ns","(name, attributes, prefix, uri, namespaces)",""],["param","XMLRPC::XMLParser::AbstractTreeParser","XMLRPC/XMLParser/AbstractTreeParser.html#method-i-param","(node)",""],["params","XMLRPC::XMLParser::AbstractTreeParser","XMLRPC/XMLParser/AbstractTreeParser.html#method-i-params","(node, call=true)",""],["parse","XMLRPC::XMLParser::LibXMLStreamParser::LibXMLStreamListener","XMLRPC/XMLParser/LibXMLStreamParser/LibXMLStreamListener.html#method-i-parse","(str)",""],["parse","XMLRPC::XMLParser::REXMLStreamParser::StreamListener","XMLRPC/XMLParser/REXMLStreamParser/StreamListener.html#method-i-parse","(str)",""],["parseMethodCall","XMLRPC::XMLParser::AbstractStreamParser","XMLRPC/XMLParser/AbstractStreamParser.html#method-i-parseMethodCall","(str)",""],["parseMethodCall","XMLRPC::XMLParser::AbstractTreeParser","XMLRPC/XMLParser/AbstractTreeParser.html#method-i-parseMethodCall","(str)",""],["parseMethodResponse","XMLRPC::XMLParser::AbstractStreamParser","XMLRPC/XMLParser/AbstractStreamParser.html#method-i-parseMethodResponse","(str)",""],["parseMethodResponse","XMLRPC::XMLParser::AbstractTreeParser","XMLRPC/XMLParser/AbstractTreeParser.html#method-i-parseMethodResponse","(str)",""],["parse_content_type","XMLRPC::ParseContentType","XMLRPC/ParseContentType.html#method-i-parse_content_type","(str)",""],["parse_set_cookies","XMLRPC::Client","XMLRPC/Client.html#method-i-parse_set_cookies","(set_cookies)",""],["parse_sig","XMLRPC::Service::BasicInterface","XMLRPC/Service/BasicInterface.html#method-i-parse_sig","(sig)",""],["parser","XMLRPC::ParserWriterChooseMixin","XMLRPC/ParserWriterChooseMixin.html#method-i-parser","()",""],["password=","XMLRPC::Client","XMLRPC/Client.html#method-i-password-3D","(new_password)","<p>Changes the password for the Basic Authentication header to\n<code>new_password</code>\n"],["pi","XMLRPC::XMLWriter::Simple","XMLRPC/XMLWriter/Simple.html#method-i-pi","(name, *params)",""],["pi","XMLRPC::XMLWriter::XMLParser","XMLRPC/XMLWriter/XMLParser.html#method-i-pi","(name, *params)",""],["process","XMLRPC::BasicServer","XMLRPC/BasicServer.html#method-i-process","(data)",""],["proxy","XMLRPC::Client","XMLRPC/Client.html#method-i-proxy","(prefix=nil, *args)","<p>Returns an object of class XMLRPC::Client::Proxy, initialized with\n<code>prefix</code> and <code>args</code>.\n<p>A proxy object returned …\n"],["proxy2","XMLRPC::Client","XMLRPC/Client.html#method-i-proxy2","(prefix=nil, *args)","<p>Almost the same like XMLRPC::Client#proxy only that a call on the returned\nXMLRPC::Client::Proxy object …\n"],["proxy2_async","XMLRPC::Client","XMLRPC/Client.html#method-i-proxy2_async","(prefix=nil, *args)","<p>Same as XMLRPC::Client#proxy2, but can be called concurrently.\n<p>See also XMLRPC::Client#proxy_async\n"],["proxy_async","XMLRPC::Client","XMLRPC/Client.html#method-i-proxy_async","(prefix=nil, *args)","<p>Similar to XMLRPC::Client#proxy, however can be called concurrently and use\na new connection for each …\n"],["removeWhitespacesAndComments","XMLRPC::XMLParser::AbstractTreeParser","XMLRPC/XMLParser/AbstractTreeParser.html#method-i-removeWhitespacesAndComments","(node)","<p>Removes all whitespaces but in the tags i4, i8, int, boolean.… and all\ncomments\n"],["require_path_info?","XMLRPC::WEBrickServlet","XMLRPC/WEBrickServlet.html#method-i-require_path_info-3F","()","<p>Deprecated from WEBrick/1.2.2, but does not break anything.\n"],["sec=","XMLRPC::DateTime","XMLRPC/DateTime.html#method-i-sec-3D","(value)","<p>Set <code>value</code> as the new date/time component.\n<p>Raises an ArgumentError if the given <code>value</code> isn&#39;t between …\n"],["serve","XMLRPC::CGIServer","XMLRPC/CGIServer.html#method-i-serve","()","<p>Call this after you have added all you handlers to the server.\n<p>This method processes a XML-RPC method …\n"],["serve","XMLRPC::ModRubyServer","XMLRPC/ModRubyServer.html#method-i-serve","()","<p>Call this after you have added all you handlers to the server.\n<p>This method processes a XML-RPC method …\n"],["serve","XMLRPC::Server","XMLRPC/Server.html#method-i-serve","()","<p>Call this after you have added all you handlers to the server. This method\nstarts the server to listen …\n"],["service","XMLRPC::WEBrickServlet","XMLRPC/WEBrickServlet.html#method-i-service","(request, response)",""],["set_auth","XMLRPC::Client","XMLRPC/Client.html#method-i-set_auth","()",""],["set_default_handler","XMLRPC::BasicServer","XMLRPC/BasicServer.html#method-i-set_default_handler","(&handler)","<p>Sets <code>handler</code> as the default-handler, which is called when no\nhandler for a method-name is found.\n<p><code>handler</code> …\n"],["set_parser","XMLRPC::ParserWriterChooseMixin","XMLRPC/ParserWriterChooseMixin.html#method-i-set_parser","(parser)","<p>Sets the XMLParser to use for parsing XML documents.\n<p>Should be an instance of a class from module XMLRPC::XMLParser …\n"],["set_service_hook","XMLRPC::BasicServer","XMLRPC/BasicServer.html#method-i-set_service_hook","(&handler)","<p>A service-hook is called for each service request (RPC).\n<p>You can use a service-hook for example to wrap …\n"],["set_valid_ip","XMLRPC::WEBrickServlet","XMLRPC/WEBrickServlet.html#method-i-set_valid_ip","(*ip_addr)","<p>Specifies the valid IP addresses that are allowed to connect to the server.\n<p>Each IP is either a String …\n"],["set_writer","XMLRPC::ParserWriterChooseMixin","XMLRPC/ParserWriterChooseMixin.html#method-i-set_writer","(writer)","<p>Sets the XMLWriter to use for generating XML output.\n<p>Should be an instance of a class from module XMLRPC::XMLWriter …\n"],["shutdown","XMLRPC::Server","XMLRPC/Server.html#method-i-shutdown","()","<p>Stops and shuts the server down.\n"],["startElement","XMLRPC::XMLParser::StreamParserMixin","XMLRPC/XMLParser/StreamParserMixin.html#method-i-startElement","(name, attrs=[])",""],["string","XMLRPC::XMLParser::AbstractTreeParser","XMLRPC/XMLParser/AbstractTreeParser.html#method-i-string","(node)",""],["struct","XMLRPC::Convert","XMLRPC/Convert.html#method-c-struct","(hash)","<p>Converts the given <code>hash</code> to a marshalled object.\n<p>Returns the given <code>hash</code> if an exception occurs.\n"],["struct","XMLRPC::XMLParser::AbstractTreeParser","XMLRPC/XMLParser/AbstractTreeParser.html#method-i-struct","(node)",""],["tag","XMLRPC::XMLWriter::Abstract","XMLRPC/XMLWriter/Abstract.html#method-i-tag","(name, txt)",""],["text","XMLRPC::XMLParser::AbstractTreeParser","XMLRPC/XMLParser/AbstractTreeParser.html#method-i-text","(node)","<p>_nodeType is defined in the subclass\n"],["text","XMLRPC::XMLWriter::Simple","XMLRPC/XMLWriter/Simple.html#method-i-text","(txt)",""],["text","XMLRPC::XMLWriter::XMLParser","XMLRPC/XMLWriter/XMLParser.html#method-i-text","(txt)",""],["text_zero_one","XMLRPC::XMLParser::AbstractTreeParser","XMLRPC/XMLParser/AbstractTreeParser.html#method-i-text_zero_one","(node)","<p>The node `node` has empty string or string\n"],["timeout=","XMLRPC::Client","XMLRPC/Client.html#method-i-timeout-3D","(new_timeout)","<p>Sets the Net::HTTP#read_timeout and Net::HTTP#open_timeout to\n<code>new_timeout</code>\n"],["to_a","XMLRPC::DateTime","XMLRPC/DateTime.html#method-i-to_a","()","<p>Returns all date/time components in an array.\n<p>Returns +[year, month, day, hour, min, sec]+.\n"],["to_date","XMLRPC::DateTime","XMLRPC/DateTime.html#method-i-to_date","()","<p>Return a Date object of the date which represents <code>self</code>.\n<p>The Date object do <em>not</em> contain the time component …\n"],["to_h","XMLRPC::FaultException","XMLRPC/FaultException.html#method-i-to_h","()","<p>The <code>faultCode</code> and <code>faultString</code> of the exception in\na Hash.\n"],["to_time","XMLRPC::DateTime","XMLRPC/DateTime.html#method-i-to_time","()","<p>Return a Time object of the date/time which represents <code>self</code>.\n<p>The timezone used is GMT.\n"],["user=","XMLRPC::Client","XMLRPC/Client.html#method-i-user-3D","(new_user)","<p>Changes the user for the Basic Authentication header to\n<code>new_user</code>\n"],["v_nil","XMLRPC::XMLParser::AbstractTreeParser","XMLRPC/XMLParser/AbstractTreeParser.html#method-i-v_nil","(node)",""],["value","XMLRPC::XMLParser::AbstractTreeParser","XMLRPC/XMLParser/AbstractTreeParser.html#method-i-value","(node)",""],["wrong_type","XMLRPC::Create","XMLRPC/Create.html#method-i-wrong_type","(value)",""],["year=","XMLRPC::DateTime","XMLRPC/DateTime.html#method-i-year-3D","(value)","<p>Set <code>value</code> as the new date/time component.\n<p>Raises ArgumentError if the given <code>value</code> is out of range, or …\n"]]}}